{"ast":null,"code":"var conversions = require('./conversions');\n/*\n\tthis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\n\nvar models = Object.keys(conversions);\n\nfunction buildGraph() {\n  var graph = {};\n\n  for (var len = models.length, i = 0; i < len; i++) {\n    graph[models[i]] = {\n      // http://jsperf.com/1-vs-infinity\n      // micro-opt, but this is simple.\n      distance: -1,\n      parent: null\n    };\n  }\n\n  return graph;\n} // https://en.wikipedia.org/wiki/Breadth-first_search\n\n\nfunction deriveBFS(fromModel) {\n  var graph = buildGraph();\n  var queue = [fromModel]; // unshift -> queue -> pop\n\n  graph[fromModel].distance = 0;\n\n  while (queue.length) {\n    var current = queue.pop();\n    var adjacents = Object.keys(conversions[current]);\n\n    for (var len = adjacents.length, i = 0; i < len; i++) {\n      var adjacent = adjacents[i];\n      var node = graph[adjacent];\n\n      if (node.distance === -1) {\n        node.distance = graph[current].distance + 1;\n        node.parent = current;\n        queue.unshift(adjacent);\n      }\n    }\n  }\n\n  return graph;\n}\n\nfunction link(from, to) {\n  return function (args) {\n    return to(from(args));\n  };\n}\n\nfunction wrapConversion(toModel, graph) {\n  var path = [graph[toModel].parent, toModel];\n  var fn = conversions[graph[toModel].parent][toModel];\n  var cur = graph[toModel].parent;\n\n  while (graph[cur].parent) {\n    path.unshift(graph[cur].parent);\n    fn = link(conversions[graph[cur].parent][cur], fn);\n    cur = graph[cur].parent;\n  }\n\n  fn.conversion = path;\n  return fn;\n}\n\nmodule.exports = function (fromModel) {\n  var graph = deriveBFS(fromModel);\n  var conversion = {};\n  var models = Object.keys(graph);\n\n  for (var len = models.length, i = 0; i < len; i++) {\n    var toModel = models[i];\n    var node = graph[toModel];\n\n    if (node.parent === null) {\n      // no possible conversion, or this node is the source model.\n      continue;\n    }\n\n    conversion[toModel] = wrapConversion(toModel, graph);\n  }\n\n  return conversion;\n};","map":{"version":3,"sources":["C:/Users/xshi/Documents/Xuefei.Doc/design/avatars/node_modules/color-convert/route.js"],"names":["conversions","require","models","Object","keys","buildGraph","graph","len","length","i","distance","parent","deriveBFS","fromModel","queue","current","pop","adjacents","adjacent","node","unshift","link","from","to","args","wrapConversion","toModel","path","fn","cur","conversion","module","exports"],"mappings":"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","sourcesContent":["var conversions = require('./conversions');\n\n/*\n\tthis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\n// https://jsperf.com/object-keys-vs-for-in-with-closure/3\nvar models = Object.keys(conversions);\n\nfunction buildGraph() {\n\tvar graph = {};\n\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tvar graph = buildGraph();\n\tvar queue = [fromModel]; // unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tvar current = queue.pop();\n\t\tvar adjacents = Object.keys(conversions[current]);\n\n\t\tfor (var len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tvar adjacent = adjacents[i];\n\t\t\tvar node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tvar path = [graph[toModel].parent, toModel];\n\tvar fn = conversions[graph[toModel].parent][toModel];\n\n\tvar cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tvar graph = deriveBFS(fromModel);\n\tvar conversion = {};\n\n\tvar models = Object.keys(graph);\n\tfor (var len = models.length, i = 0; i < len; i++) {\n\t\tvar toModel = models[i];\n\t\tvar node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// no possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n"]},"metadata":{},"sourceType":"script"}